From f270a0fb8b3ad4ce0ea1c888b7d3d56372eed656 Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jorge@foundries.io>
Date: Sat, 30 Jan 2021 18:03:11 +0100
Subject: [PATCH 2/2] kernel: anx7625 - add traces

---
 drivers/gpu/drm/bridge/anx7625_drv.c | 151 +++++++++++++++++++++++++--
 drivers/rtc/rtc-pcf8563.c            |   7 ++
 2 files changed, 152 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/bridge/anx7625_drv.c b/drivers/gpu/drm/bridge/anx7625_drv.c
index ff1a9ab725b7..c97aedba70c3 100644
--- a/drivers/gpu/drm/bridge/anx7625_drv.c
+++ b/drivers/gpu/drm/bridge/anx7625_drv.c
@@ -30,6 +30,21 @@
 #include <video/display_timing.h>
 #include "anx7625.h"
 
+#define DEBUG 1
+
+#ifdef DEBUG
+#ifdef DRM_DEV_DEBUG_DRIVER
+#undef DRM_DEV_DEBUG_DRIVER
+#define DRM_DEV_DEBUG_DRIVER(dev, fmt, ...) dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
+#endif
+
+#ifdef DRM_DEV_ERROR
+#undef DRM_DEV_ERROR
+#define DRM_DEV_ERROR(dev, fmt, ...) dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
+#endif
+#endif
+
+
 /*
  * There is a sync issue while access I2C register between AP(CPU) and
  * internal firmware(OCM), to avoid the race condition, AP should access
@@ -1046,24 +1061,28 @@ static void anx7625_config(struct anx7625_data *ctx)
 static int anx7625_chip_register_init(struct anx7625_data *ctx)
 {
 	struct device *dev = &ctx->client->dev;
-	int ret;
+	int ret = 0;
 
 	/* interrupt vector mask bit as platform needed 0: enable 1: disable */
 	ret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 				INTERFACE_CHANGE_INT_MASK,
 				INT_MASK_OFF);
+
 	/* AUTO_RDO_ENABLE */
 	ret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,
 				AUTO_PD_MODE,
 				AUTO_PD_ENABLE);
+
 	/* Maximum Voltage in 100mV units: 5V */
 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 				 MAX_VOLTAGE_SETTING,
 				 0x32);
+
 	/* Maximum Power in 500mW units: 60W */
 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 				 MAX_POWER_SETTING,
 				 0x78);
+
 	/* Minimum Power in 500mW units: 1W */
 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 				 MIN_POWER_SETTING,
@@ -1268,6 +1287,8 @@ static void anx7625_start_dp_work(struct anx7625_data *ctx)
 		return;
 
 	DRM_DEV_DEBUG_DRIVER(dev, "Secure OCM version=%02x\n", ret);
+
+	return;
 }
 
 static int anx7625_read_hpd_status_p0(struct anx7625_data *ctx)
@@ -1805,10 +1826,13 @@ static irqreturn_t anx7625_cable_irq(int irq, void *data)
 	struct anx7625_data *ctx = (struct anx7625_data *)data;
 	unsigned char val = gpiod_get_value(ctx->pdata.gpio_cbl_det);
 
-	if (atomic_read(&ctx->cable_connected) == val)
+	if (atomic_read(&ctx->cable_connected) == val) {
+		printk("anx: cable irq NONE (status didnt change, must be spurious)\n");
 		return IRQ_NONE;
+	}
 
 	atomic_set(&ctx->cable_connected, val);
+	printk("anx: cable irq (%s)\n", atomic_read(&ctx->cable_connected) ? "PLUGGED" : "UNPLUGGED");
 
 	return IRQ_WAKE_THREAD;
 }
@@ -1818,6 +1842,7 @@ static irqreturn_t anx7625_cable_isr(int irq, void *data)
 	struct anx7625_data *ctx = (struct anx7625_data *)data;
 
 	mutex_lock(&ctx->lock);
+	printk("anx: cable isr\n");
 	if (!atomic_read(&ctx->cable_connected)) {
 		if (ctx->hpd_status)
 			anx7625_stop_dp_work(ctx);
@@ -1825,11 +1850,13 @@ static irqreturn_t anx7625_cable_isr(int irq, void *data)
 		atomic_set(&ctx->power_status, 0);
 		sys_sta_bak = 0;
 		mutex_unlock(&ctx->lock);
+		printk("anx: cable isr done\n");
 		return IRQ_HANDLED;
 	}
 
 	if (!atomic_read(&ctx->power_status))
 		anx7625_chip_control(ctx, 1);
+	printk("anx: cable isr done\n");
 	mutex_unlock(&ctx->lock);
 
 	return IRQ_HANDLED;
@@ -1839,11 +1866,16 @@ static irqreturn_t anx7625_comm_irq(int irq, void *data)
 {
 	struct anx7625_data *ctx = (struct anx7625_data *)data;
 
-	if (atomic_read(&ctx->power_status) < 1)
-		return IRQ_NONE;
+	if (atomic_read(&ctx->power_status) < 1) {
+		printk("anx: comm irq NONE - no power, must be spurious\n");
+			return IRQ_NONE;
+	}
 
-	if (!atomic_read(&ctx->cable_connected))
+	if (!atomic_read(&ctx->cable_connected)) {
+		printk("anx: comm irq NONE - cable not connected, must be spurious\n");
 		return IRQ_NONE;
+	}
+	printk("anx: comm irq\n");
 
 	return IRQ_WAKE_THREAD;
 }
@@ -1851,24 +1883,126 @@ static irqreturn_t anx7625_comm_irq(int irq, void *data)
 static irqreturn_t anx7625_comm_isr(int irq, void *data)
 {
 	struct anx7625_data *ctx = (struct anx7625_data *)data;
-	int sys_status, itype, ivector;
+	int sys_status, itype, ivector, cc_status;
 
 #define STS_HPD_CHANGE \
 	(((sys_status & HPD_STATUS) != \
 	 (sys_sta_bak & HPD_STATUS)) ? HPD_STATUS_CHANGE : 0)
 
 	mutex_lock(&ctx->lock);
+	printk("anx: comm isr starts -------------------------------\n");
 	itype = anx7625_reg_read(ctx, ctx->i2c.tcpc_client,
 				 TCPC_INTR_ALERT_1);
 
 	ivector = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client,
 				   INTERFACE_CHANGE_INT);
 
+	printk("anx: comms - interrupt vector (0x44) 0x%x:\n", ivector);
+	if (ivector & BIT(0))
+		printk("anx: - MSG INT\n");
+	if (ivector & BIT(1))
+		printk("anx: - Reserved\n");
+	if (ivector & BIT(2))
+		printk("anx: - VCONN change\n");
+	if (ivector & BIT(3))
+		printk("anx: - VBUS change\n");
+	if (ivector & BIT(4))
+		printk("anx: - CC status change\n");
+	if (ivector & BIT(5))
+		printk("anx: - Data role change\n");
+	if (ivector & BIT(6))
+		printk("anx: - As  power consumer, update the max of RDOs V and W after PD negotiation\n");
+	if (ivector & BIT(7))
+		printk("anx: - DP HPD change\n");
+
 	anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 			  INTERFACE_CHANGE_INT,
 			  ivector &(~ivector));
 
 	sys_status = anx7625_read_hpd_status_p0(ctx);
+	printk("anx: comms - system status (0x45) 0x%x:\n", sys_status);
+
+	if (sys_status & BIT(0))
+		printk("anx: - Reserved\n");
+
+	if (sys_status & BIT(1))
+		printk("anx: - Reserved \n");
+
+//	if (ivector & BIT(2))
+	{
+		if (sys_status & BIT(2))
+			printk("anx: - VCONN status ON\n");
+		if (!(sys_status & BIT(2)))
+			printk("anx: - VCONN status OFF\n");
+	}
+
+//	if (ivector & BIT(3))
+	{
+		if (sys_status & BIT(3))
+			printk("anx: - VBUS power provider\n");
+		if (!(sys_status & BIT(3)))
+			printk("anx: - VBUS power consumer\n");
+	}
+
+//	if (ivector & BIT(5))
+	{
+		if (sys_status & BIT(5))
+			printk("anx: - Data Role: DFP\n");
+		if (!(sys_status & BIT(5)))
+			printk("anx: - Data Role: UFP\n");
+	}
+
+	if (sys_status & BIT(6))
+		printk("anx: - Reserved\n");
+
+//	if (ivector & BIT(7))
+	{
+		if (sys_status & BIT(7))
+			printk("anx: - DP HPD high\n");
+		if (!(sys_status & BIT(7)))
+			printk("anx: - DP HPD low\n");
+	}
+
+        cc_status = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, 0x46);
+        printk("anx: comms - CC status (0x46) c1 = 0x%x, c2 = 0x%x:\n",
+	       cc_status & 0x0F, cc_status & 0xF0);
+
+//	if (ivector & BIT(4))
+{
+	switch (cc_status & 0x0F) {
+	case 0:
+		printk("anx: CC1: SRC.Open\n"); break;
+	case 1:
+		printk("anx: CC1: SRC.Rd\n"); break;
+	case 2:
+		printk("anx: CC1: SRC.Ra\n"); break;
+	case 4:
+		printk("anx: CC1: SNK.default\n"); break;
+	case 8:
+		printk("anx: CC1: SNK.power.1.5\n"); break;
+	case 12:
+		printk("anx: CC1: SNK.power.3.0\n"); break;
+	default:
+		printk("anx: CC1: Reserved\n");
+	}
+
+	switch (cc_status & 0xF0) {
+	case 0:
+		printk("anx: CC2: SRC.Open\n"); break;
+	case 1:
+		printk("anx: CC2: SRC.Rd\n"); break;
+	case 2:
+		printk("anx: CC2: SRC.Ra\n"); break;
+	case 4:
+		printk("anx: CC2: SNK.default\n"); break;
+	case 8:
+		printk("anx: CC2: SNK.power.1.5\n"); break;
+	case 12:
+		printk("anx: CC2: SNK.power.3.0\n"); break;
+	default:
+		printk("anx: CC2: Reserved\n");
+	}
+}
 
 	if ((ivector & HPD_STATUS_CHANGE) || STS_HPD_CHANGE)
 		dp_hpd_change_handler(ctx, sys_status & HPD_STATUS);
@@ -1881,6 +2015,7 @@ static irqreturn_t anx7625_comm_isr(int irq, void *data)
 
 	if (ctx->bridge_attached)
 		drm_helper_hpd_irq_event(ctx->connector.dev);
+	printk("anx: comm isr done ---------------------------------\n");
 	mutex_unlock(&ctx->lock);
 
 	return IRQ_HANDLED;
@@ -1918,6 +2053,7 @@ static int anx7625_i2c_probe(struct i2c_client *client,
 	ret = gpiod_to_irq(platform->pdata.gpio_cbl_det);
 	if (ret < 0)
 		goto free_platform;
+
 	platform->pdata.cbl_det_irq = ret;
 
 	ret = gpiod_to_irq(platform->pdata.gpio_intr_comm);
@@ -1949,13 +2085,16 @@ static int anx7625_i2c_probe(struct i2c_client *client,
 
 	if (IS_ENABLED(CONFIG_OF))
 		platform->bridge.of_node = client->dev.of_node;
+
 	platform->bridge.funcs = &anx7625_bridge_funcs;
 	drm_bridge_add(&platform->bridge);
 
+	printk("anx probed\n");
 	return 0;
 
 free_platform:
 	kfree(platform);
+	anx7625_unregister_i2c_dummy_clients(platform);
 
 	return ret;
 }
diff --git a/drivers/rtc/rtc-pcf8563.c b/drivers/rtc/rtc-pcf8563.c
index 9b1d65f7da9c..17592fabfa40 100644
--- a/drivers/rtc/rtc-pcf8563.c
+++ b/drivers/rtc/rtc-pcf8563.c
@@ -558,6 +558,13 @@ static int pcf8563_probe(struct i2c_client *client,
 	struct pcf8563 *pcf8563;
 	int err;
 	unsigned char buf;
+	static int defer = 2;
+
+	if (defer) {
+		defer--;
+		return -EPROBE_DEFER;
+	}
+
 
 	dev_dbg(&client->dev, "%s\n", __func__);
 
-- 
2.17.1

