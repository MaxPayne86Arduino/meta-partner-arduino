From 18da3286095a0a48f40de29e309a9ccb3f41b652 Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jorge@foundries.io>
Date: Wed, 3 Feb 2021 15:43:30 +0100
Subject: [PATCH] an7625: hdmi audio

Only Signed 16 bit Little Endian, Rate 48000 Hz, Stereo WAV validated.
Requires additional work for other use cases.

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>
---
 drivers/gpu/drm/bridge/Makefile               |   2 +-
 .../drm/bridge/{anx7625_drv.c => anx7625.c}   | 166 ++++++++++++-----
 drivers/gpu/drm/bridge/anx7625.h              |  16 --
 drivers/gpu/drm/bridge/anx7625_audio.c        | 170 +-----------------
 4 files changed, 127 insertions(+), 227 deletions(-)
 rename drivers/gpu/drm/bridge/{anx7625_drv.c => anx7625.c} (93%)

diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index f2ede53d363d..397a09871419 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -21,4 +21,4 @@ obj-y += cadence/
 obj-y += synopsys/
 obj-$(CONFIG_DRM_ITE_IT6263) += it6263.o
 obj-$(CONFIG_DRM_SEC_MIPI_DSIM) += sec-dsim.o
-obj-y += anx7625_audio.o anx7625_drv.o
+obj-y += anx7625.o
diff --git a/drivers/gpu/drm/bridge/anx7625_drv.c b/drivers/gpu/drm/bridge/anx7625.c
similarity index 93%
rename from drivers/gpu/drm/bridge/anx7625_drv.c
rename to drivers/gpu/drm/bridge/anx7625.c
index c5ed91553edf..4f59badb35ed 100644
--- a/drivers/gpu/drm/bridge/anx7625_drv.c
+++ b/drivers/gpu/drm/bridge/anx7625.c
@@ -29,6 +29,10 @@
 #include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
 #include <video/display_timing.h>
+#include <sound/core.h>
+#include <sound/hdmi-codec.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
 #include "anx7625.h"
 
 #define DEBUG 1
@@ -36,12 +40,14 @@
 #ifdef DEBUG
 #ifdef DRM_DEV_DEBUG_DRIVER
 #undef DRM_DEV_DEBUG_DRIVER
-#define DRM_DEV_DEBUG_DRIVER(dev, fmt, ...) dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
+#define DRM_DEV_DEBUG_DRIVER(dev, fmt, ...) \
+dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
 #endif
 
 #ifdef DRM_DEV_ERROR
 #undef DRM_DEV_ERROR
-#define DRM_DEV_ERROR(dev, fmt, ...) dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
+#define DRM_DEV_ERROR(dev, fmt, ...) \
+dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
 #endif
 #endif
 
@@ -114,8 +120,8 @@ static int anx7625_reg_block_read(struct anx7625_data *ctx,
 	return ret;
 }
 
-int anx7625_reg_write(struct anx7625_data *ctx, struct i2c_client *client,
-			     u8 reg_addr, u8 reg_val)
+static int anx7625_reg_write(struct anx7625_data *ctx,
+			     struct i2c_client *client, u8 reg_addr, u8 reg_val)
 {
 	struct device *dev = &client->dev;
 	int ret;
@@ -128,8 +134,7 @@ int anx7625_reg_write(struct anx7625_data *ctx, struct i2c_client *client,
 	return ret;
 }
 
-int anx7625_write_or(struct anx7625_data *ctx,
-			    struct i2c_client *client,
+static int anx7625_write_or(struct anx7625_data *ctx, struct i2c_client *client,
 			    u8 offset, u8 mask)
 {
 	int val;
@@ -142,8 +147,7 @@ int anx7625_write_or(struct anx7625_data *ctx,
 }
 
 static int anx7625_write_and(struct anx7625_data *ctx,
-			     struct i2c_client *client,
-			     u8 offset, u8 mask)
+			     struct i2c_client *client, u8 offset, u8 mask)
 {
 	int val;
 
@@ -154,9 +158,9 @@ static int anx7625_write_and(struct anx7625_data *ctx,
 	return anx7625_reg_write(ctx, client, offset, (val & (mask)));
 }
 
-int anx7625_write_and_or(struct anx7625_data *ctx,
-				struct i2c_client *client,
-				u8 offset, u8 and_mask, u8 or_mask)
+static int anx7625_write_and_or(struct anx7625_data *ctx,
+				struct i2c_client *client, u8 offset,
+				u8 and_mask, u8 or_mask)
 {
 	int val;
 
@@ -275,7 +279,7 @@ static int anx7625_video_mute_control(struct anx7625_data *ctx,
 	return ret;
 }
 
-int anx7625_config_audio_input(struct anx7625_data *ctx)
+static int anx7625_config_audio_input(struct anx7625_data *ctx)
 {
 	struct device *dev = &ctx->client->dev;
 	int ret;
@@ -738,6 +742,85 @@ static void sp_tx_get_rx_bw(struct anx7625_data *ctx, u8 *bw)
 	}
 }
 
+static int anx7625_hdmi_hw_params(struct device *dev, void *data,
+				  struct hdmi_codec_daifmt *fmt,
+				  struct hdmi_codec_params *hparms)
+{
+	DRM_DEV_DEBUG_DRIVER(dev, "anx7625_hdmi_hw_params: "
+			     " sample rate %d, width %d.\n",
+			     hparms->sample_rate, hparms->sample_width);
+
+	DRM_DEV_DEBUG_DRIVER(dev, "anx7625_hdmi format: "
+			     " audio format 0x%x, invert clock %d.\n",
+			     fmt->fmt, fmt->bit_clk_inv);
+
+	/*
+	 * Signed 16 bit Little Endian, Rate 48000 Hz, Stereo [OK]
+	 *
+	 * TODO: needs handling of other use cases
+	 */
+
+	return 0;
+}
+
+static int anx7625_audio_startup(struct device *dev, void *data)
+{
+	struct anx7625_data *ctx = dev_get_drvdata(dev);
+	return anx7625_config_audio_input(ctx);
+}
+
+static void anx7625_audio_shutdown(struct device *dev, void *data)
+{
+}
+
+static int anx7625_hdmi_i2s_get_dai_id(struct snd_soc_component *component,
+				       struct device_node *endpoint)
+{
+	struct of_endpoint of_ep;
+	int ret;
+
+	ret = of_graph_parse_endpoint(endpoint, &of_ep);
+	if (ret < 0)
+		return ret;
+
+	/* HDMI sound should be located as reg = <3> (sound port 0) */
+	if (of_ep.port == 3)
+		return 0;
+
+	return -EINVAL;
+}
+
+static const struct hdmi_codec_ops anx7625_codec_ops = {
+	.hw_params	= anx7625_hdmi_hw_params,
+	.audio_startup	= anx7625_audio_startup,
+	.audio_shutdown = anx7625_audio_shutdown,
+	.get_dai_id	= anx7625_hdmi_i2s_get_dai_id,
+};
+
+static const struct hdmi_codec_pdata codec_data = {
+	.ops = &anx7625_codec_ops,
+	.max_i2s_channels = 2,
+	.i2s = 1,
+};
+
+static int anx7625_audio_init(struct device *dev, struct anx7625_data *anx7625)
+{
+	anx7625->audio_pdev = platform_device_register_data(dev,
+							    HDMI_CODEC_DRV_NAME,
+							    PLATFORM_DEVID_AUTO,
+							    &codec_data,
+							    sizeof(codec_data));
+	return PTR_ERR_OR_ZERO(anx7625->audio_pdev);
+}
+
+static void anx7625_audio_exit(struct anx7625_data *anx7625)
+{
+	if (anx7625->audio_pdev) {
+		platform_device_unregister(anx7625->audio_pdev);
+		anx7625->audio_pdev = NULL;
+	}
+}
+
 static void anx7625_dp_start(struct anx7625_data *ctx)
 {
 	struct device *dev = &ctx->client->dev;
@@ -1929,47 +2012,34 @@ static irqreturn_t anx7625_comm_isr(int irq, void *data)
 	if (sys_status & BIT(1))
 		printk("anx: - Reserved \n");
 
-//	if (ivector & BIT(2))
-	{
-		if (sys_status & BIT(2))
-			printk("anx: - VCONN status ON\n");
-		if (!(sys_status & BIT(2)))
-			printk("anx: - VCONN status OFF\n");
-	}
 
-//	if (ivector & BIT(3))
-	{
-		if (sys_status & BIT(3))
-			printk("anx: - VBUS power provider\n");
-		if (!(sys_status & BIT(3)))
-			printk("anx: - VBUS power consumer\n");
-	}
+	if (sys_status & BIT(2))
+		printk("anx: - VCONN status ON\n");
+	if (!(sys_status & BIT(2)))
+		printk("anx: - VCONN status OFF\n");
 
-//	if (ivector & BIT(5))
-	{
-		if (sys_status & BIT(5))
-			printk("anx: - Data Role: DFP\n");
-		if (!(sys_status & BIT(5)))
-			printk("anx: - Data Role: UFP\n");
-	}
+	if (sys_status & BIT(3))
+		printk("anx: - VBUS power provider\n");
+	if (!(sys_status & BIT(3)))
+		printk("anx: - VBUS power consumer\n");
+
+	if (sys_status & BIT(5))
+		printk("anx: - Data Role: DFP\n");
+	if (!(sys_status & BIT(5)))
+		printk("anx: - Data Role: UFP\n");
 
 	if (sys_status & BIT(6))
 		printk("anx: - Reserved\n");
 
-//	if (ivector & BIT(7))
-	{
-		if (sys_status & BIT(7))
-			printk("anx: - DP HPD high\n");
-		if (!(sys_status & BIT(7)))
-			printk("anx: - DP HPD low\n");
-	}
+	if (sys_status & BIT(7))
+		printk("anx: - DP HPD high\n");
+	if (!(sys_status & BIT(7)))
+		printk("anx: - DP HPD low\n");
 
         cc_status = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, 0x46);
         printk("anx: comms - CC status (0x46) c1 = 0x%x, c2 = 0x%x:\n",
 	       cc_status & 0x0F, cc_status & 0xF0);
 
-//	if (ivector & BIT(4))
-{
 	switch (cc_status & 0x0F) {
 	case 0:
 		printk("anx: CC1: SRC.Open\n"); break;
@@ -2003,7 +2073,6 @@ static irqreturn_t anx7625_comm_isr(int irq, void *data)
 	default:
 		printk("anx: CC2: Reserved\n");
 	}
-}
 
 	if ((ivector & HPD_STATUS_CHANGE) || STS_HPD_CHANGE)
 		dp_hpd_change_handler(ctx, sys_status & HPD_STATUS);
@@ -2016,6 +2085,7 @@ static irqreturn_t anx7625_comm_isr(int irq, void *data)
 
 	if (ctx->bridge_attached)
 		drm_helper_hpd_irq_event(ctx->connector.dev);
+
 	printk("anx: comm isr done ---------------------------------\n");
 	mutex_unlock(&ctx->lock);
 
@@ -2031,7 +2101,7 @@ static int anx7625_i2c_probe(struct i2c_client *client,
 	struct regulator *regulator;
 	int ret;
 
-	printk("anx probe starts\n");
+	printk("anx probing ...\n");
 
 	regulator = devm_regulator_get(dev, "vdda");
 	if (IS_ERR(regulator)) {
@@ -2101,7 +2171,14 @@ static int anx7625_i2c_probe(struct i2c_client *client,
 	platform->bridge.funcs = &anx7625_bridge_funcs;
 	drm_bridge_add(&platform->bridge);
 
+	ret = anx7625_audio_init(dev, platform);
+	if (ret) {
+		DRM_DEV_DEBUG_DRIVER(dev, "can't initialize audio\n");
+		return ret;
+	}
+
 	printk("anx probed\n");
+
 	return 0;
 
 free_platform:
@@ -2117,6 +2194,7 @@ static int anx7625_i2c_remove(struct i2c_client *client)
 
 	drm_bridge_remove(&platform->bridge);
 	anx7625_unregister_i2c_dummy_clients(platform);
+	anx7625_audio_exit(platform);
 	kfree(platform);
 
 	return 0;
diff --git a/drivers/gpu/drm/bridge/anx7625.h b/drivers/gpu/drm/bridge/anx7625.h
index 6c9e8b57c4f0..0d685f7896d5 100644
--- a/drivers/gpu/drm/bridge/anx7625.h
+++ b/drivers/gpu/drm/bridge/anx7625.h
@@ -435,20 +435,4 @@ struct anx7625_data {
 	struct platform_device *audio_pdev;
 };
 
-int anx7625_reg_write(struct anx7625_data *ctx,
-			     struct i2c_client *client,
-			     u8 reg_addr, u8 reg_val);
-int anx7625_write_and_or(struct anx7625_data *ctx,
-				struct i2c_client *client,
-				u8 offset, u8 and_mask, u8 or_mask);
-int anx7625_write_or(struct anx7625_data *ctx,
-			    struct i2c_client *client,
-			    u8 offset, u8 mask);
-
-
-int anx7625_config_audio_input(struct anx7625_data *ctx);
-
-int anx7625_audio_init(struct device *dev, struct anx7625_data *anx7625);
-void anx7625_audio_exit(struct anx7625_data *anx7625);
-
 #endif  /* __ANX7625_H__ */
diff --git a/drivers/gpu/drm/bridge/anx7625_audio.c b/drivers/gpu/drm/bridge/anx7625_audio.c
index 30fbf6ed7663..a64dd2526b92 100644
--- a/drivers/gpu/drm/bridge/anx7625_audio.c
+++ b/drivers/gpu/drm/bridge/anx7625_audio.c
@@ -5,10 +5,6 @@
  * Copyright (c) 2016, Linaro Limited
  */
 
-#include <sound/core.h>
-#include <sound/hdmi-codec.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
 #include <linux/of_graph.h>
 
 #include "anx7625.h"
@@ -19,172 +15,14 @@
 #ifdef DRM_DEV_DEBUG_DRIVER
 #undef DRM_DEV_DEBUG_DRIVER
 #endif
-#define DRM_DEV_DEBUG_DRIVER(dev, fmt, ...) dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
+#define DRM_DEV_DEBUG_DRIVER(dev, fmt, ...) \
+dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
 
 #ifdef DRM_DEV_ERROR
 #undef DRM_DEV_ERROR
 #endif
-#define DRM_DEV_ERROR(dev, fmt, ...) dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
+#define DRM_DEV_ERROR(dev, fmt, ...) \
+dev_printk(KERN_ERR, dev, fmt, ##__VA_ARGS__)
 #endif
 
-int anx7625_hdmi_hw_params(struct device *dev, void *data,
-			   struct hdmi_codec_daifmt *fmt,
-			   struct hdmi_codec_params *hparms)
-{
-	struct anx7625_data *ctx = dev_get_drvdata(dev);
-//	unsigned int audio_source, i2s_format = 0;
-//	unsigned int invert_clock;
-	unsigned int rate;
-	unsigned int len;
-	int ret;
 
-	DRM_DEV_DEBUG_DRIVER(dev, "anx7625_hdmi_hw_params sample rate %d, width %d.\n",
-			     hparms->sample_rate, hparms->sample_width);
-
-	return 0;	switch (hparms->sample_rate) {
-	case 32000:
-		rate = AUDIO_FS_32K;
-		break;
-	case 44100:
-		rate = AUDIO_FS_441K;
-		break;
-	case 48000:
-		rate = AUDIO_FS_48K;
-		break;
-	case 88200:
-		rate = AUDIO_FS_882K;
-		break;
-	case 96000:
-		rate = AUDIO_FS_96K;
-		break;
-	case 176400:
-		rate = AUDIO_FS_1764K;
-		break;
-	case 192000:
-		rate = AUDIO_FS_192K;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	switch (hparms->sample_width) {
-	case 16:
-		len = AUDIO_W_LEN_16_20MAX;
-		break;
-	case 18:
-		len = AUDIO_W_LEN_18_20MAX;
-		break;
-	case 20:
-		len = AUDIO_W_LEN_20_20MAX;
-		break;
-	case 24:
-		len = AUDIO_W_LEN_24_24MAX;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	switch (fmt->fmt) {
-	case HDMI_I2S:
-		//audio_source = ADV7511_AUDIO_SOURCE_I2S;
-		//i2s_format = ADV7511_I2S_FORMAT_I2S;
-		break;
-	case HDMI_RIGHT_J:
-	case HDMI_LEFT_J:
-	case HDMI_DSP_A:
-	case HDMI_DSP_B:
-	case HDMI_AC97:
-	case HDMI_SPDIF:
-	default:
-		return -EINVAL;
-	}
-
-//	invert_clock = fmt->bit_clk_inv;
-
-	/* Channel num */
-	ret = anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,
-				AUDIO_CHANNEL_STATUS_6, I2S_CH_2 << 5);
-
-	/* FS */
-	ret |= anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,
-				    AUDIO_CHANNEL_STATUS_4, 0xF0, rate);
-
-	/* Word length */
-	ret |= anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,
-				    AUDIO_CHANNEL_STATUS_5, 0xF0, len);
-
-	/* Audio change flag */
-	ret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,
-				AP_AV_STATUS, AP_AUDIO_CHG);
-
-	return ret? -EINVAL: 0;
-}
-
-static int audio_startup(struct device *dev, void *data)
-{
-	struct anx7625_data *ctx = dev_get_drvdata(dev);
-
-DRM_DEV_DEBUG_DRIVER(dev, "audio_startup\n");
-	return anx7625_config_audio_input(ctx);
-}
-
-static void audio_shutdown(struct device *dev, void *data)
-{
-DRM_DEV_DEBUG_DRIVER(dev, "audio_shutdown\n");
-}
-
-static int anx7625_hdmi_i2s_get_dai_id(struct snd_soc_component *component,
-					struct device_node *endpoint)
-{
-	struct of_endpoint of_ep;
-	int ret;
-
-	ret = of_graph_parse_endpoint(endpoint, &of_ep);
-	if (ret < 0) {
-printk("anx7625_hdmi_i2s_get_dai_id: ERROR: endpoint not found\n");
-		return ret;
-	}
-	/*
-	 * HDMI sound should be located as reg = <3>
-	 * Then, it is sound port 0
-	 */
-	if (of_ep.port == 3) {
-printk("anx7625_hdmi_i2s_get_dai_id: of_ep.port == 3\n");
-		return 0;
-	}
-printk("anx7625_hdmi_i2s_get_dai_id: ERROR\n");
-	return -EINVAL;
-}
-
-static const struct hdmi_codec_ops anx7625_codec_ops = {
-	.hw_params	= anx7625_hdmi_hw_params,
-	.audio_startup	= audio_startup,
-	.audio_shutdown = audio_shutdown,
-	.get_dai_id	= anx7625_hdmi_i2s_get_dai_id,
-};
-
-static const struct hdmi_codec_pdata codec_data = {
-	.ops = &anx7625_codec_ops,
-	.max_i2s_channels = 2,
-	.i2s = 1,
-};
-
-int anx7625_audio_init(struct device *dev, struct anx7625_data *anx7625)
-{
-	anx7625->audio_pdev = platform_device_register_data(dev,
-					HDMI_CODEC_DRV_NAME,
-					PLATFORM_DEVID_AUTO,
-					&codec_data,
-					sizeof(codec_data));
-DRM_DEV_DEBUG_DRIVER(dev, "anx7625_audio_init: audio_pdev %p\n", anx7625->audio_pdev);
-	return PTR_ERR_OR_ZERO(anx7625->audio_pdev);
-}
-
-void anx7625_audio_exit(struct anx7625_data *anx7625)
-{
-printk("anx7625_audio_exit\n");
-	if (anx7625->audio_pdev) {
-		platform_device_unregister(anx7625->audio_pdev);
-		anx7625->audio_pdev = NULL;
-	}
-}
-- 
2.17.1

