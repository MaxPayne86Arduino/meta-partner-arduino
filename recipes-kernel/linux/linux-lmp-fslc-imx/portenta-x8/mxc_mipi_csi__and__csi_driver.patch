diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index 433f2d124d2c..7fab60ede08e 100644
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -35,7 +35,6 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
-#include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/media-bus-format.h>
 #include <media/v4l2-common.h>
@@ -244,28 +243,34 @@ struct mx6s_fmt {
 static struct mx6s_fmt formats[] = {
 	{
 		.name		= "UYVY-16",
-		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.fourcc	= V4L2_PIX_FMT_UYVY,
 		.pixelformat	= V4L2_PIX_FMT_UYVY,
 		.mbus_code	= MEDIA_BUS_FMT_UYVY8_2X8,
 		.bpp		= 2,
 	}, {
 		.name		= "YUYV-16",
-		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.fourcc	= V4L2_PIX_FMT_YUYV,
 		.pixelformat	= V4L2_PIX_FMT_YUYV,
 		.mbus_code	= MEDIA_BUS_FMT_YUYV8_2X8,
 		.bpp		= 2,
 	}, {
 		.name		= "YUV32 (X-Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUV32,
+		.fourcc	= V4L2_PIX_FMT_YUV32,
 		.pixelformat	= V4L2_PIX_FMT_YUV32,
 		.mbus_code	= MEDIA_BUS_FMT_AYUV8_1X32,
 		.bpp		= 4,
 	}, {
 		.name		= "RAWRGB8 (SBGGR8)",
-		.fourcc		= V4L2_PIX_FMT_SBGGR8,
+		.fourcc	= V4L2_PIX_FMT_SBGGR8,
 		.pixelformat	= V4L2_PIX_FMT_SBGGR8,
 		.mbus_code	= MEDIA_BUS_FMT_SBGGR8_1X8,
 		.bpp		= 1,
+	}, {
+		.name		= "RAWRGB10 (SBGGR10)",
+		.fourcc	= V4L2_PIX_FMT_SBGGR10,
+		.pixelformat	= V4L2_PIX_FMT_SBGGR10,
+		.mbus_code	= MEDIA_BUS_FMT_SBGGR10_1X10,
+		.bpp		= 2,
 	}
 };
 
@@ -381,7 +386,10 @@ struct mx6s_fmt *format_by_mbus(u32 code)
 
 	for (i = 0; i < NUM_FORMATS; i++) {
 		if (formats[i].mbus_code == code)
+		{
+			printk("%s %s %d: mbus_code %d 0x%04X\n", __FILE__, __func__, __LINE__, formats[i].mbus_code, formats[i].mbus_code);
 			return formats + i;
+		}
 	}
 
 	pr_err("unknown mbus:0x%x\n", code);
@@ -471,7 +479,7 @@ static void csi_init_interface(struct mx6s_csi_dev *csi_dev)
 	val |= BIT_MCLKEN;
 	__raw_writel(val, csi_dev->regbase + CSI_CSICR1);
 
-	imag_para = (640 << 16) | 960;
+	imag_para = (1080 << 16) | 1920;
 	__raw_writel(imag_para, csi_dev->regbase + CSI_CSIIMAG_PARA);
 
 	val = BIT_DMA_REFLASH_RFF;
@@ -823,7 +831,7 @@ static void mx6s_csi_disable(struct mx6s_csi_dev *csi_dev)
 static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 {
 	struct v4l2_pix_format *pix = &csi_dev->pix;
-	u32 cr1, cr18;
+	u32 cr1, cr3, cr18;
 	u32 width;
 
 	if (pix->field == V4L2_FIELD_INTERLACED) {
@@ -835,13 +843,43 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 		csi_buf_stride_set(csi_dev, 0);
 	}
 
+	dev_info(csi_dev->dev,"in function: mx6s_configure_csi - pixelformat 0x%x\n",csi_dev->fmt->pixelformat);
+
+	/*
+	  Our sensor is configured to output RAW10 from mipi.
+	  Just use it.
+	*/
+	csi_set_imagpara(csi_dev, pix->width, pix->height);
+	cr1 = csi_read(csi_dev, CSI_CSICR1);
+	cr1 &= ~BIT_GCLK_MODE;
+	cr1 |= BIT_PIXEL_BIT;
+
+	cr3 = csi_read(csi_dev, CSI_CSICR3);
+	cr3 |= BIT_TWO_8BIT_SENSOR;
+
+	cr18 = csi_read(csi_dev, CSI_CSICR18);
+	cr18 &= ~BIT_MIPI_DATA_FORMAT_MASK;
+	cr18 |= BIT_MIPI_DATA_FORMAT_RAW10;
+
+	csi_write(csi_dev, cr1, CSI_CSICR1);
+	csi_write(csi_dev, cr3, CSI_CSICR3);
+	csi_write(csi_dev, cr18, CSI_CSICR18);
+	return 0;
+
+#if 0
 	switch (csi_dev->fmt->pixelformat) {
 	case V4L2_PIX_FMT_YUV32:
 	case V4L2_PIX_FMT_SBGGR8:
+		dev_info(csi_dev->dev,"pixelformat:  --BIT_MIPI_DATA_FORMAT_RAW8--\n");
+		width = pix->width;
+		break;
+	case V4L2_PIX_FMT_SBGGR10:
 		width = pix->width;
+		dev_info(csi_dev->dev,"pixelformat: V4L2_PIX_FMT_SBGGR10\n");
 		break;
 	case V4L2_PIX_FMT_UYVY:
 	case V4L2_PIX_FMT_YUYV:
+		dev_info(csi_dev->dev,"pixelformat:  --V4L2_PIX_FMT_YUYV--\n");
 		if (csi_dev->csi_mipi_mode == true)
 			width = pix->width;
 		else
@@ -850,6 +888,8 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 		break;
 	default:
 		pr_debug("   case not supported\n");
+		dev_info(csi_dev->dev,"   case not supported\n");
+		display_registers_to_dmesg(csi_dev);
 		return -EINVAL;
 	}
 	csi_set_imagpara(csi_dev, width, pix->height);
@@ -857,28 +897,52 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 	if (csi_dev->csi_mipi_mode == true) {
 		cr1 = csi_read(csi_dev, CSI_CSICR1);
 		cr1 &= ~BIT_GCLK_MODE;
+		cr3 = csi_read(csi_dev, CSI_CSICR3);
+
+		if (V4L2_PIX_FMT_SBGGR10 == csi_dev->fmt->pixelformat) {
+		  cr1 |= BIT_PIXEL_BIT;
+		  cr3 |= BIT_TWO_8BIT_SENSOR;
+		}
+		else {
+		  cr1 &= ~BIT_PIXEL_BIT;
+		  cr3 &= ~BIT_TWO_8BIT_SENSOR;
+		}
+
 		csi_write(csi_dev, cr1, CSI_CSICR1);
+		csi_write(csi_dev, cr3, CSI_CSICR3);
 
 		cr18 = csi_read(csi_dev, CSI_CSICR18);
 		cr18 &= ~BIT_MIPI_DATA_FORMAT_MASK;
 		cr18 |= BIT_DATA_FROM_MIPI;
 
+		dev_info(csi_dev->dev,"in function: mx6s_configure_csi - pixelformat 0x%x\n",csi_dev->fmt->pixelformat);
+
 		switch (csi_dev->fmt->pixelformat) {
 		case V4L2_PIX_FMT_UYVY:
 		case V4L2_PIX_FMT_YUYV:
+			dev_info(csi_dev->dev,"pixelformat:  --V4L2_PIX_FMT_YUYV--\n");
 			cr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;
 			break;
 		case V4L2_PIX_FMT_SBGGR8:
 			cr18 |= BIT_MIPI_DATA_FORMAT_RAW8;
+			dev_info(csi_dev->dev,"pixelformat:  --BIT_MIPI_DATA_FORMAT_RAW8--\n");
+			break;
+		case V4L2_PIX_FMT_SBGGR10:
+			cr18 |= BIT_MIPI_DATA_FORMAT_RAW10;
+			dev_info(csi_dev->dev,"pixelformat:  --V4L2_PIX_FMT_SBGGR10--\n");
 			break;
 		default:
 			pr_debug("   fmt not supported\n");
+			dev_info(csi_dev->dev,"   fmt not supported\n");
+			display_registers_to_dmesg(csi_dev);
 			return -EINVAL;
 		}
 
 		csi_write(csi_dev, cr18, CSI_CSICR18);
 	}
+
 	return 0;
+#endif
 }
 
 static int mx6s_start_streaming(struct vb2_queue *vq, unsigned int count)
@@ -1390,7 +1454,7 @@ static int mx6s_vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 
 	fmt = format_by_mbus(code.code);
 	if (!fmt) {
-		dev_err(csi_dev->dev, "mbus (0x%08x) invalid.\n", code.code);
+		dev_dbg(csi_dev->dev, "mbus (0x%08x) invalid.\n", code.code);
 		return -EINVAL;
 	}
 
@@ -1463,9 +1527,17 @@ static int mx6s_vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	csi_dev->pix.sizeimage = f->fmt.pix.sizeimage;
 	csi_dev->pix.field     = f->fmt.pix.field;
 	csi_dev->type          = f->type;
-	dev_dbg(csi_dev->dev, "set to pixelformat '%4.6s'\n",
+	dev_info(csi_dev->dev, "set to pixelformat '%4.6s'\n",
 			(char *)&csi_dev->fmt->name);
 
+
+
+	dev_info(csi_dev->dev, "set to pixelformat '%4.6s'\n",	(char *)&csi_dev->fmt->name);
+	dev_info(csi_dev->dev, "type %d\n",csi_dev->type );
+	dev_info(csi_dev->dev, "width %d\n",csi_dev->pix.width );
+	dev_info(csi_dev->dev, "height %d\n",csi_dev->pix.height );
+
+
 	/* Config csi */
 	mx6s_configure_csi(csi_dev);
 
@@ -1620,6 +1692,7 @@ static int mx6s_vidioc_enum_framesizes(struct file *file, void *priv,
 		.index = fsize->index,
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
 	};
+
 	int ret;
 
 	fmt = format_by_fourcc(fsize->pixel_format);
@@ -1899,6 +1972,13 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 		return -EINVAL;
 	csi_dev->soc = of_id->data;
 
+	dev_info(dev, "platform_device name: %s\n",pdev->name);
+	dev_info(dev, "name: %s\n",of_id->name);
+	dev_info(dev, "type: %s\n",of_id->type);
+	dev_info(dev, "compatible: %s\n",of_id->compatible);
+	dev_info(dev, "baseaddr_switch: %x\n",csi_dev->soc->baseaddr_switch);
+	dev_info(dev, "rx_fifo_rst: %d\n",csi_dev->soc->rx_fifo_rst);
+
 	snprintf(csi_dev->v4l2_dev.name,
 		 sizeof(csi_dev->v4l2_dev.name), "CSI");
 
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index 069a0b9bb961..9a3d32562f36 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -322,6 +322,10 @@ static const struct csis_pix_format mipi_csis_formats[] = {
 		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
 		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW8,
 		.data_alignment = 8,
+	}, {
+		.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW10,
+		.data_alignment = 16,
 	}
 };
 
