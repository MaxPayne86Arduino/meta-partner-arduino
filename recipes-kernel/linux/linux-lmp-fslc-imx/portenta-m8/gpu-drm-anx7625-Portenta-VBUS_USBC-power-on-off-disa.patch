From 16a5332658178ccadd6fc1901142e4582b958493 Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jorge@foundries.io>
Date: Fri, 12 Feb 2021 08:53:56 +0100
Subject: [PATCH] gpu: drm: anx7625 (Portenta) - VBUS_USBC power on/off
 disabled

Compile out the VBUS_USBC workaround (leave the code for future
integration)

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>
---
 drivers/gpu/drm/bridge/anx7625.c | 55 +++++++++++++++++++++++++-------
 1 file changed, 44 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/bridge/anx7625.c b/drivers/gpu/drm/bridge/anx7625.c
index d785c56d4bcc..a33d3421e482 100644
--- a/drivers/gpu/drm/bridge/anx7625.c
+++ b/drivers/gpu/drm/bridge/anx7625.c
@@ -1105,13 +1105,15 @@ static int sp_tx_edid_read(struct anx7625_data *ctx, u8 *pedid_blocks_buf)
 static void anx7625_power_on(struct anx7625_data *ctx)
 {
 	struct device *dev = &ctx->client->dev;
+#if 0
 	struct gpio_desc *pwr;
-
+#endif
 	if (!ctx->pdata.low_power_mode) {
 		DRM_DEV_DEBUG_DRIVER(dev, "not low power mode!\n");
 		return;
 	}
 
+#if 0
 	/* portenta: VBUS_USBC on (0) */
 	pwr = devm_gpiod_get_optional(dev, "usbc_pwr", GPIOD_OUT_LOW);
 	if (!IS_ERR(pwr)) {
@@ -1122,7 +1124,9 @@ static void anx7625_power_on(struct anx7625_data *ctx)
 	} else
 		DRM_DEV_DEBUG_DRIVER(dev, "power on, VBUS_USBC failed %ld\n",
 				     PTR_ERR(pwr));
-
+#else
+	DRM_DEV_DEBUG_DRIVER(dev, "power on\n");
+#endif
 	/* 10ms: as per data sheet */
 	gpiod_set_value(ctx->pdata.gpio_p_on, 1);
 	usleep_range(10000, 10100);
@@ -1135,8 +1139,9 @@ static void anx7625_power_on(struct anx7625_data *ctx)
 static void anx7625_power_standby(struct anx7625_data *ctx)
 {
 	struct device *dev = &ctx->client->dev;
+#if 0
 	struct gpio_desc *pwr;
-
+#endif
 	if (!ctx->pdata.low_power_mode) {
 		DRM_DEV_DEBUG_DRIVER(dev, "not low power mode!\n");
 		return;
@@ -1147,7 +1152,7 @@ static void anx7625_power_standby(struct anx7625_data *ctx)
 
 	gpiod_set_value(ctx->pdata.gpio_p_on, 0);
 	usleep_range(1000, 1100);
-
+#if 0
 	/* portenta: VBUS_USBC off (1) */
 	pwr = devm_gpiod_get_optional(dev, "usbc_pwr", GPIOD_OUT_HIGH);
 	if (!IS_ERR(pwr) ) {
@@ -1158,6 +1163,10 @@ static void anx7625_power_standby(struct anx7625_data *ctx)
 	} else
 		DRM_DEV_DEBUG_DRIVER(dev, "power off, VBUS_USBC failed %ld\n",
 				     PTR_ERR(pwr));
+#else
+	DRM_DEV_DEBUG_DRIVER(dev, "power off\n");
+#endif
+
 }
 
 static void anx7625_config(struct anx7625_data *ctx)
@@ -1187,15 +1196,15 @@ static int anx7625_chip_register_init(struct anx7625_data *ctx)
 				 MAX_VOLTAGE_SETTING,
 				 0x32);
 
-	/* Maximum Power in 500mW units: 60W */
+	/* Maximum Power in 500mW units: 15W */
 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 				 MAX_POWER_SETTING,
-				 0x78);
+				 30);
 
 	/* Minimum Power in 500mW units: 1W */
 	ret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,
 				 MIN_POWER_SETTING,
-				 0x02);
+				 00);
 	if (ret < 0)
 		DRM_DEV_DEBUG_DRIVER(dev, "init registers failed.\n");
 	else
@@ -1308,13 +1317,18 @@ static void anx7625_chip_control(struct anx7625_data *ctx, int state)
 static void anx7625_init_gpio(struct anx7625_data *platform)
 {
 	struct device *dev = &platform->client->dev;
+#if 0
 	struct gpio_desc *pwr;
 
 	DRM_DEV_DEBUG_DRIVER(dev, "gpio initialization, VBUS_USBC=1\n");
+#else
+	DRM_DEV_DEBUG_DRIVER(dev, "gpio initialization\n");
+#endif
 
+#if 0
 	/* portenta: VBUS_USBC off (gpio = 1) */
 	pwr = devm_gpiod_get_optional(dev, "usbc_pwr", GPIOD_OUT_HIGH);
-
+#endif
 	/* keep the ANX powered off: power/reset gpios are active high  */
 	platform->pdata.gpio_p_on = devm_gpiod_get_optional(dev, "enable",
 							       GPIOD_OUT_LOW);
@@ -1331,6 +1345,7 @@ static void anx7625_init_gpio(struct anx7625_data *platform)
 
 	if (platform->pdata.gpio_p_on && platform->pdata.gpio_reset) {
 		platform->pdata.low_power_mode = 1;
+#if 0
 		DRM_DEV_DEBUG_DRIVER(dev, "LOW POWER MODE enabled, "
 				     "VBUS_USBC(%d) = %d, "
 				     "POWER_EN(%d) = %d, "
@@ -1341,6 +1356,15 @@ static void anx7625_init_gpio(struct anx7625_data *platform)
 				     gpiod_get_value(platform->pdata.gpio_p_on),
 				     desc_to_gpio(platform->pdata.gpio_reset),
 				     gpiod_get_value(platform->pdata.gpio_reset));
+#else
+		DRM_DEV_DEBUG_DRIVER(dev, "LOW POWER MODE enabled, "
+				     "POWER_EN(%d) = %d, "
+				     "RESET_N(%d) =  %d\n",
+				     desc_to_gpio(platform->pdata.gpio_p_on),
+				     gpiod_get_value(platform->pdata.gpio_p_on),
+				     desc_to_gpio(platform->pdata.gpio_reset),
+				     gpiod_get_value(platform->pdata.gpio_reset));
+#endif
 		atomic_set(&platform->power_status, 0);
 	} else {
 		/* this is untested, probably needs some work */
@@ -1350,9 +1374,11 @@ static void anx7625_init_gpio(struct anx7625_data *platform)
 		atomic_set(&platform->power_status, 1);
 	}
 
+#if 0
 	/* return VBUS_USBC back to users */
 	if (!IS_ERR(pwr))
 		devm_gpiod_put(dev, pwr);
+#endif
 }
 
 static void anx7625_stop_dp_work(struct anx7625_data *ctx)
@@ -1604,11 +1630,12 @@ static enum drm_mode_status
 anx7625_connector_mode_valid(struct drm_connector *connector,
 			     struct drm_display_mode *mode)
 {
+#if 0
 	struct anx7625_data *ctx = connector_to_anx7625(connector);
 	struct device *dev = &ctx->client->dev;
 
 	DRM_DEV_DEBUG_DRIVER(dev, "drm modes valid verify\n");
-
+#endif
 	if (mode->clock > SUPPORT_PIXEL_CLOCK)
 		return MODE_CLOCK_HIGH;
 
@@ -1760,15 +1787,18 @@ anx7625_bridge_mode_valid(struct drm_bridge *bridge,
 	struct anx7625_data *ctx = bridge_to_anx7625(bridge);
 	struct device *dev = &ctx->client->dev;
 
+#if 0
 	DRM_DEV_DEBUG_DRIVER(dev, "drm mode checking\n");
+#endif
 
 	/* Max 1200p at 5.4 Ghz, one lane, pixel clock 300M */
 	if (mode->clock > SUPPORT_PIXEL_CLOCK) {
 		DRM_DEV_DEBUG_DRIVER(dev, "drm mode invalid, pixelclock \n");
 		return MODE_CLOCK_HIGH;
 	}
-
+#if 0
 	DRM_DEV_DEBUG_DRIVER(dev, "drm mode valid.\n");
+#endif
 
 	return MODE_OK;
 }
@@ -1972,8 +2002,11 @@ static irqreturn_t anx7625_cable_isr(int irq, void *data)
 
 	printk("anx: cable isr\n");
 	if (!atomic_read(&ctx->cable_connected)) {
-		if (ctx->hpd_status)
+		if (ctx->hpd_status) {
+			printk("anx: stop DP work\n");
 			anx7625_stop_dp_work(ctx);
+		}
+
 		anx7625_power_standby(ctx);
 		atomic_set(&ctx->power_status, 0);
 		sys_sta_bak = 0;
-- 
2.30.0

