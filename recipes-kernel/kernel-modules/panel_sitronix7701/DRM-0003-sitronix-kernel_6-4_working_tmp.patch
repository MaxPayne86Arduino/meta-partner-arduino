From fb3b1c81976dc06f45ac6c6ff9ccc3174648f972 Mon Sep 17 00:00:00 2001
From: OpenEmbedded <oe.patch@oe>
Date: Thu, 24 Aug 2023 15:36:27 +0000
Subject: [PATCH] test 2

---
 drivers/gpu/drm/panel/panel-sitronix-st7701.c | 148 ++++++++++++++----
 1 file changed, 118 insertions(+), 30 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-sitronix-st7701.c b/drivers/gpu/drm/panel/panel-sitronix-st7701.c
index 5fc7067f6de3..74088ea73c16 100644
--- a/drivers/gpu/drm/panel/panel-sitronix-st7701.c
+++ b/drivers/gpu/drm/panel/panel-sitronix-st7701.c
@@ -185,7 +185,7 @@ static void st7701_switch_cmd_bkx(struct st7701 *st7701, bool cmd2, u8 bkx)
 	u8 val;
 
 	if (cmd2)
-		val = DSI_CMD2 | FIELD_PREP(DSI_CMD2BK_MASK, bkx);
+		val = DSI_CMD2 | FIELD_PREP(DSI_CMD2BK_MASK, bkx); //@TODO different from H7
 	else
 		val = DSI_CMD1;
 
@@ -198,6 +198,7 @@ static void st7701_init_sequence(struct st7701 *st7701)
 	const struct drm_display_mode *mode = desc->mode;
 	const u8 linecount8 = mode->vdisplay / 8;
 	const u8 linecountrem2 = (mode->vdisplay % 8) / 2;
+	int i = 0;
 
 	ST7701_DSI(st7701, MIPI_DCS_SOFT_RESET, 0x00);
 
@@ -209,12 +210,29 @@ static void st7701_init_sequence(struct st7701 *st7701)
 	msleep(st7701->sleep_delay);
 
 	/* Command2, BK0 */
-	st7701_switch_cmd_bkx(st7701, true, 0);
+	st7701_switch_cmd_bkx(st7701, true, 0); //OK
+
+	/**
+	 * @TODO
+	 * GAMMA CLUSTER SETTINGS
+	 * H7 FW vs this driver
+	 * 
+	 * {0xB0,0x40,0xc9,0x91,0x0d,0x12,0x07,0x02,0x09,0x09,0x1f,0x04,0x50,0x0f,0xe4,0x29,0xdf}-H7
+	 * {0xB0,0x00,0x0E,0x15,0x0F,0x11,0x08,0x08,0x08,0x08,0x23,0x04,0x13,0x12,0x2B,0x34,0x1F}-DRV
+	 * 
+	 * {0xB1,0x40,0xcb,0xd0,0x11,0x92,0x07,0x00,0x08,0x07,0x1c,0x06,0x53,0x12,0x63,0xeb,0xdf}-H7
+	 * {0xB1,0x00,0x0E,0x95,0x0F,0x13,0x07,0x09,0x08,0x08,0x22,0x04,0x10,0x0E,0x2C,0x34,0x1F}-DRV
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK0_LNESET, 0x63,0x00);
+	ST7701_DSI(st7701, DSI_CMD2_BK0_PORCTRL, 0x11, 0x02);
+	ST7701_DSI(st7701, DSI_CMD2_BK0_INVSEL, 0x01, 0x08);
+	ST7701_DSI(st7701, 0xCC, 0x18);
 
 	mipi_dsi_dcs_write(st7701->dsi, DSI_CMD2_BK0_PVGAMCTRL,
 			   desc->pv_gamma, ARRAY_SIZE(desc->pv_gamma));
 	mipi_dsi_dcs_write(st7701->dsi, DSI_CMD2_BK0_NVGAMCTRL,
 			   desc->nv_gamma, ARRAY_SIZE(desc->nv_gamma));
+
 	/*
 	 * Vertical line count configuration:
 	 * Line[6:0]: select number of vertical lines of the TFT matrix in
@@ -226,55 +244,87 @@ static void st7701_init_sequence(struct st7701 *st7701)
 	 * Total number of vertical lines:
 	 * LN = ((Line[6:0] + 1) * 8) + (LDE_EN ? Line_delta[1:0] * 2 : 0)
 	 */
+
+	/* @TODO ORIGINAL CODE HERE
+	 * Values are 0xC0 0xE9 0x03
 	ST7701_DSI(st7701, DSI_CMD2_BK0_LNESET,
 		   FIELD_PREP(DSI_CMD2_BK0_LNESET_LINE_MASK, linecount8 - 1) |
 		   (linecountrem2 ? DSI_CMD2_BK0_LNESET_LDE_EN : 0),
 		   FIELD_PREP(DSI_CMD2_BK0_LNESET_LINEDELTA, linecountrem2));
+	 */
+
+	/* @TODO ORIGINAL CODE HERE
+	 * Values are 0xC1 0x04 0x12
 	ST7701_DSI(st7701, DSI_CMD2_BK0_PORCTRL,
 		   FIELD_PREP(DSI_CMD2_BK0_PORCTRL_VBP_MASK,
 			      mode->vtotal - mode->vsync_end),
 		   FIELD_PREP(DSI_CMD2_BK0_PORCTRL_VFP_MASK,
 			      mode->vsync_start - mode->vdisplay));
+	 */
+
 	/*
 	 * Horizontal pixel count configuration:
 	 * PCLK = 512 + (RTNI[4:0] * 16)
 	 * The PCLK is number of pixel clock per line, which matches
 	 * mode htotal. The minimum is 512 PCLK.
 	 */
+
+
+	/* @TODO ORIGINAL CODE HERE
+	 * Values are 0xC2 0x37 0x01
 	ST7701_DSI(st7701, DSI_CMD2_BK0_INVSEL,
 		   DSI_CMD2_BK0_INVSEL_ONES_MASK |
 		   FIELD_PREP(DSI_CMD2_BK0_INVSEL_NLINV_MASK, desc->nlinv),
 		   FIELD_PREP(DSI_CMD2_BK0_INVSEL_RTNI_MASK,
 			      (clamp((u32)mode->htotal, 512U, 1008U) - 512) / 16));
+	 */
 
 	/* Command2, BK1 */
 	st7701_switch_cmd_bkx(st7701, true, 1);
 
 	/* Vop = 3.5375V + (VRHA[7:0] * 0.0125V) */
+	/** @TODO
+	 * Value is 0x45
 	ST7701_DSI(st7701, DSI_CMD2_BK1_VRHS,
 		   FIELD_PREP(DSI_CMD2_BK1_VRHA_MASK,
 			      DIV_ROUND_CLOSEST(desc->vop_uv - 3537500, 12500)));
-
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK1_VRHS, 0x65);
+	
 	/* Vcom = 0.1V + (VCOM[7:0] * 0.0125V) */
+	/** @TODO
+	 * Value is 0x13
 	ST7701_DSI(st7701, DSI_CMD2_BK1_VCOM,
 		   FIELD_PREP(DSI_CMD2_BK1_VCOM_MASK,
 			      DIV_ROUND_CLOSEST(desc->vcom_uv - 100000, 12500)));
-
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK1_VCOM, 0x34);
+	
 	/* Vgh = 11.5V + (VGHSS[7:0] * 0.5V) */
+	/** @TODO
+	 * Value is 0x07
 	ST7701_DSI(st7701, DSI_CMD2_BK1_VGHSS,
 		   FIELD_PREP(DSI_CMD2_BK1_VGHSS_MASK,
 			      DIV_ROUND_CLOSEST(clamp(desc->vgh_mv,
 						      (u16)11500,
 						      (u16)17000) - 11500,
 						500)));
-
-	ST7701_DSI(st7701, DSI_CMD2_BK1_TESTCMD, DSI_CMD2_BK1_TESTCMD_VAL);
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK1_VGHSS, 0x87);
+	
+	ST7701_DSI(st7701, DSI_CMD2_BK1_TESTCMD, DSI_CMD2_BK1_TESTCMD_VAL); //OK
 
 	/* Vgl is non-linear */
+	/** @TODO
+	 * Value is 0x47
 	ST7701_DSI(st7701, DSI_CMD2_BK1_VGLS,
 		   DSI_CMD2_BK1_VGLS_ONES |
 		   FIELD_PREP(DSI_CMD2_BK1_VGLS_MASK, st7701_vgls_map(st7701)));
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK1_VGLS, 0x49);
 
+	/** @TODO
+	 * Value is 0xC5
 	ST7701_DSI(st7701, DSI_CMD2_BK1_PWCTLR1,
 		   FIELD_PREP(DSI_CMD2_BK1_PWRCTRL1_AP_MASK,
 			      desc->gamma_op_bias) |
@@ -282,29 +332,35 @@ static void st7701_init_sequence(struct st7701 *st7701)
 			      desc->input_op_bias) |
 		   FIELD_PREP(DSI_CMD2_BK1_PWRCTRL1_APOS_MASK,
 			      desc->output_op_bias));
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK1_PWCTLR1, 0x85);
 
 	/* Avdd = 6.2V + (AVDD[1:0] * 0.2V) , Avcl = -4.4V - (AVCL[1:0] * 0.2V) */
 	ST7701_DSI(st7701, DSI_CMD2_BK1_PWCTLR2,
 		   FIELD_PREP(DSI_CMD2_BK1_PWRCTRL2_AVDD_MASK,
 			      DIV_ROUND_CLOSEST(desc->avdd_mv - 6200, 200)) |
 		   FIELD_PREP(DSI_CMD2_BK1_PWRCTRL2_AVCL_MASK,
-			      DIV_ROUND_CLOSEST(-4400 + desc->avcl_mv, 200)));
+			      DIV_ROUND_CLOSEST(-4400 + desc->avcl_mv, 200))); //OK
 
 	/* T2D = 0.2us * T2D[3:0] */
+	/** @TODO
+	 * Value is 0x08
 	ST7701_DSI(st7701, DSI_CMD2_BK1_SPD1,
 		   DSI_CMD2_BK1_SPD1_ONES_MASK |
 		   FIELD_PREP(DSI_CMD2_BK1_SPD1_T2D_MASK,
 			      DIV_ROUND_CLOSEST(desc->t2d_ns, 200)));
+	 */
+	ST7701_DSI(st7701, DSI_CMD2_BK1_SPD1, 0x78);
 
 	/* T3D = 4us + (0.8us * T3D[3:0]) */
 	ST7701_DSI(st7701, DSI_CMD2_BK1_SPD2,
 		   DSI_CMD2_BK1_SPD2_ONES_MASK |
 		   FIELD_PREP(DSI_CMD2_BK1_SPD2_T3D_MASK,
-			      DIV_ROUND_CLOSEST(desc->t3d_ns - 4000, 800)));
+			      DIV_ROUND_CLOSEST(desc->t3d_ns - 4000, 800))); //OK
 
 	ST7701_DSI(st7701, DSI_CMD2_BK1_MIPISET1,
 		   DSI_CMD2_BK1_MIPISET1_ONES |
-		   (desc->eot_en ? DSI_CMD2_BK1_MIPISET1_EOT_EN : 0));
+		   (desc->eot_en ? DSI_CMD2_BK1_MIPISET1_EOT_EN : 0)); //OK
 }
 
 static void ts8550b_gip_sequence(struct st7701 *st7701)
@@ -314,22 +370,21 @@ static void ts8550b_gip_sequence(struct st7701 *st7701)
 	 * specific command sequence, so grab the same from vendor BSP driver.
 	 */
 	ST7701_DSI(st7701, 0xE0, 0x00, 0x00, 0x02);
-	ST7701_DSI(st7701, 0xE1, 0x0B, 0x00, 0x0D, 0x00, 0x0C, 0x00, 0x0E,
-		   0x00, 0x00, 0x44, 0x44);
-	ST7701_DSI(st7701, 0xE2, 0x33, 0x33, 0x44, 0x44, 0x64, 0x00, 0x66,
-		   0x00, 0x65, 0x00, 0x67, 0x00, 0x00);
+	ST7701_DSI(st7701, 0xE1,0x08,0x00,0x0A,0x00,0x07,0x00,0x09,0x00,0x00,0x33,0x33);
+	ST7701_DSI(st7701, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
 	ST7701_DSI(st7701, 0xE3, 0x00, 0x00, 0x33, 0x33);
 	ST7701_DSI(st7701, 0xE4, 0x44, 0x44);
-	ST7701_DSI(st7701, 0xE5, 0x0C, 0x78, 0x3C, 0xA0, 0x0E, 0x78, 0x3C,
-		   0xA0, 0x10, 0x78, 0x3C, 0xA0, 0x12, 0x78, 0x3C, 0xA0);
+	ST7701_DSI(st7701, 0xE5, 0x0E, 0x60, 0xA0, 0xa0, 0x10, 0x60, 0xA0,
+			0xA0, 0x0A, 0x60, 0xA0, 0xA0, 0x0C, 0x60, 0xA0, 0xA0);
 	ST7701_DSI(st7701, 0xE6, 0x00, 0x00, 0x33, 0x33);
 	ST7701_DSI(st7701, 0xE7, 0x44, 0x44);
-	ST7701_DSI(st7701, 0xE8, 0x0D, 0x78, 0x3C, 0xA0, 0x0F, 0x78, 0x3C,
-		   0xA0, 0x11, 0x78, 0x3C, 0xA0, 0x13, 0x78, 0x3C, 0xA0);
-	ST7701_DSI(st7701, 0xEB, 0x02, 0x02, 0x39, 0x39, 0xEE, 0x44, 0x00);
-	ST7701_DSI(st7701, 0xEC, 0x00, 0x00);
-	ST7701_DSI(st7701, 0xED, 0xFF, 0xF1, 0x04, 0x56, 0x72, 0x3F, 0xFF,
-		   0xFF, 0xFF, 0xFF, 0xF3, 0x27, 0x65, 0x40, 0x1F, 0xFF);
+	ST7701_DSI(st7701, 0xE8, 0x0D, 0x60, 0xA0, 0xA0, 0x0F, 0x60, 0xA0,
+			0xA0, 0x09, 0x60, 0xA0, 0xA0, 0x0B, 0x60, 0xA0, 0xA0);
+	ST7701_DSI(st7701, 0xEB, 0x02, 0x01, 0xE4, 0xE4, 0x44, 0x00, 0x40);
+	ST7701_DSI(st7701, 0xEC, 0x02, 0x01);
+	ST7701_DSI(st7701, 0xED, 0xAB, 0x89, 0x76, 0x54, 0x01, 0xFF, 0xFF,
+			0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x45, 0x67, 0x98, 0xBA);
 }
 
 static void dmt028vghmcmi_1a_gip_sequence(struct st7701 *st7701)
@@ -425,6 +480,7 @@ static void kd50t048a_gip_sequence(struct st7701 *st7701)
 
 static int st7701_prepare(struct drm_panel *panel)
 {
+/*
 	struct st7701 *st7701 = panel_to_st7701(panel);
 	int ret;
 
@@ -444,15 +500,35 @@ static int st7701_prepare(struct drm_panel *panel)
 	if (st7701->desc->gip_sequence)
 		st7701->desc->gip_sequence(st7701);
 
-	/* Disable Command2 */
+	// Disable Command2 
 	st7701_switch_cmd_bkx(st7701, false, 0);
-
+*/
 	return 0;
 }
 
 static int st7701_enable(struct drm_panel *panel)
 {
 	struct st7701 *st7701 = panel_to_st7701(panel);
+	int ret;
+
+	gpiod_set_value(st7701->reset, 0);
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(st7701->supplies),
+				    st7701->supplies);
+	if (ret < 0)
+		return ret;
+	msleep(20);
+
+	gpiod_set_value(st7701->reset, 1);
+	msleep(150);
+
+	st7701_init_sequence(st7701);
+
+	if (st7701->desc->gip_sequence)
+		st7701->desc->gip_sequence(st7701);
+
+	/* Disable Command2 */
+	st7701_switch_cmd_bkx(st7701, false, 0);
 
 	ST7701_DSI(st7701, MIPI_DCS_SET_DISPLAY_ON, 0x00);
 
@@ -524,12 +600,20 @@ static int st7701_get_modes(struct drm_panel *panel,
 	return 1;
 }
 
+static enum drm_panel_orientation st7701_get_orientation(struct drm_panel *panel)
+{
+	struct st7701 *st7701 = panel_to_st7701(panel);
+
+	return st7701->orientation;
+}
+
 static const struct drm_panel_funcs st7701_funcs = {
 	.disable	= st7701_disable,
 	.unprepare	= st7701_unprepare,
 	.prepare	= st7701_prepare,
 	.enable		= st7701_enable,
 	.get_modes	= st7701_get_modes,
+	//.get_orientation = st7701_get_orientation,
 };
 
 static const struct drm_display_mode ts8550b_mode = {
@@ -554,10 +638,12 @@ static const struct drm_display_mode ts8550b_mode = {
 static const struct st7701_panel_desc ts8550b_desc = {
 	.mode = &ts8550b_mode,
 	.lanes = 2,
-	.format = MIPI_DSI_FMT_RGB888,
+	.format = MIPI_DSI_FMT_RGB565,
 	.panel_sleep_delay = 80, /* panel need extra 80ms for sleep out cmd */
 
-	.pv_gamma = {
+	.pv_gamma = {0x40,0xc9,0x91,0x0d,0x12,0x07,0x02,0x09,0x09,0x1f,0x04,0x50,0x0f,0xe4,0x29,0xdf},
+
+	/*{
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC0_MASK, 0),
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
@@ -586,7 +672,9 @@ static const struct st7701_panel_desc ts8550b_desc = {
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC255_MASK, 0x1f)
 	},
-	.nv_gamma = {
+	*/
+	.nv_gamma = {0x40,0xcb,0xd0,0x11,0x92,0x07,0x00,0x08,0x07,0x1c,0x06,0x53,0x12,0x63,0xeb,0xdf},
+	/*{
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC0_MASK, 0),
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
@@ -614,7 +702,7 @@ static const struct st7701_panel_desc ts8550b_desc = {
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC251_MASK, 0x34),
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
 		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC255_MASK, 0x1f)
-	},
+	},*/
 	.nlinv = 7,
 	.vop_uv = 4400000,
 	.vcom_uv = 337500,
@@ -842,8 +930,7 @@ static int st7701_dsi_probe(struct mipi_dsi_device *dsi)
 		return -ENOMEM;
 
 	desc = of_device_get_match_data(&dsi->dev);
-	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
-			  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST;
 	dsi->format = desc->format;
 	dsi->lanes = desc->lanes;
 
@@ -879,10 +966,11 @@ static int st7701_dsi_probe(struct mipi_dsi_device *dsi)
 	 */
 	st7701->sleep_delay = 120 + desc->panel_sleep_delay;
 
+/* @TODO WORKING AROUND WESTON
 	ret = drm_panel_of_backlight(&st7701->panel);
 	if (ret)
 		return ret;
-
+*/
 	drm_panel_add(&st7701->panel);
 
 	mipi_dsi_set_drvdata(dsi, st7701);
-- 
2.25.1

